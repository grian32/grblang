#include "bytecode_emit.h"
#include "parser.h"

#include <stdio.h>
#include <stdlib.h>

void bytecode_init(BytecodeEmitter* b) {
    int initial_capacity = 128;
    b->code = malloc(initial_capacity * sizeof(uint8_t));
    b->code_size = 0;
    b->code_capacity = initial_capacity;

    b->constants = malloc(initial_capacity * sizeof(int));
    b->const_count = 0;
    b->const_capacity = initial_capacity;
}

void bytecode_resize_code(BytecodeEmitter* b) {
    int new_capacity = b->code_capacity * 2;
    uint8_t* new_code = realloc(b->code, new_capacity * sizeof(uint8_t));
    if (!new_code) {
        fprintf(stderr, "failed to realloc bytecode arr\n");
        exit(1);
    }

    b->code = new_code;
    b->code_capacity = new_capacity;
}

void bytecode_resize_const(BytecodeEmitter* b) {
    int new_capacity = b->const_capacity * 2;
    StackValue* new_constants = realloc(b->constants, new_capacity * sizeof(StackValue));
    if (!new_constants) {
        fprintf(stderr,"failed to realloc constants arr\n");
        exit(1);
    }

    b->constants = new_constants;
    b->const_capacity = new_capacity;
}

void bytecode_gen(ASTNode* node, BytecodeEmitter* b) {
    if (!node) return;

    switch (node->type) {
        case AST_INT:
            emit_push_int(b, node->int_val);
            break;
        case AST_BOOL:
            emit_push_bool(b, node->bool_val);
            break;
        case AST_BINARY_OP:
            bytecode_gen(node->binary_op.left, b);
            bytecode_gen(node->binary_op.right, b);

            switch (node->binary_op.op) {
                case TOK_PLUS: emit_iadd(b); break;
                case TOK_MINUS: emit_isub(b); break;
                case TOK_MULT: emit_imul(b); break;
                case TOK_DIV: emit_idiv(b); break;
                case TOK_GREATER: emit_igt(b); break;
                case TOK_LESS: emit_ilt(b); break;
                case TOK_EQUALS: {
                    // can just check the left node as type checker should catch cases where it's not the same type on both sides
                    if (node->binary_op.left->type == AST_INT) {
                        emit_ieq(b);
                    } else {
                        emit_beq(b);
                    }
                    break;
                }
                default: break;
            }
            break;
        case AST_UNARY_OP:
            bytecode_gen(node->unary_op.right, b);

            switch (node->unary_op.op) {
                case TOK_MINUS: emit_neg(b); break;
                case TOK_EXCLAM: emit_not(b); break;
                default: break;
            }
            break;
        case AST_VAR_DECL:
            bytecode_gen(node->var_decl.value, b);
            emit_store(b, node->var_type, node->var_decl.slot);
            break;
        case AST_VAR_ASSIGN:
            bytecode_gen(node->var_assign.value, b);
            emit_store(b, node->var_type, node->var_assign.slot);
            break;
        case AST_VAR_REF:
            emit_load(b, node->var_type, node->var_ref.slot);
            break;
        case AST_PROGRAM:
            for (int i = 0; i < node->program.count; i++) {
                bytecode_gen(node->program.statements[i], b);
            }
            break;
        case AST_IF:
            bytecode_gen(node->if_stmt.condition, b);

            int jmpn_step_start = emit_jmpn(b, 0);
            int curr_instruction_count = b->code_size;
            for (int i = 0; i < node->if_stmt.success_count; i++) {
                bytecode_gen(node->if_stmt.success_statements[i], b);
            }
            int jmpn_instruction_count = b->code_size - curr_instruction_count;
            if (node->if_stmt.fail_statements) {
                // required to skip the JMP generated by the else block
                jmpn_instruction_count++;
            }
            patch_int(b, jmpn_instruction_count, jmpn_step_start);

            if (node->if_stmt.fail_statements) {
                int jmp_step_start = emit_jmp(b, 0);
                int curr_instruction_count = b->code_size;
                for (int i = 0; i < node->if_stmt.fail_count; i++) {
                    bytecode_gen(node->if_stmt.fail_statements[i], b);
                }
                int jmp_instruction_count = b->code_size - curr_instruction_count;
                patch_int(b, jmp_instruction_count, jmp_step_start);
            }
            break;
    }
}

uint16_t add_const(BytecodeEmitter* b, StackValue val) {
    if (b->const_count >= b->const_capacity) {
        bytecode_resize_const(b);
    }

    b->constants[b->const_count] = val;
    return b->const_count++;
}

void emit_push_int(BytecodeEmitter* b, int val) {
    StackValue sv = {.type = VALUE_INT, .int_val = val};
    uint16_t idx = add_const(b, sv);
    emit_byte(b, OP_PUSH);
    emit_byte(b, (idx >> 8) & 0xFF);
    emit_byte(b, idx & 0xFF);
}

void emit_push_bool(BytecodeEmitter* b, bool val) {
    if (val) {
        emit_byte(b, OP_PUSH_TRUE);
    } else {
        emit_byte(b, OP_PUSH_FALSE);
    }
}

void emit_byte(BytecodeEmitter* b, uint8_t val) {
    if (b->code_size >= b->code_capacity) {
        bytecode_resize_code(b);
    }

    b->code[b->code_size++] = val;
}

void emit_store(BytecodeEmitter* b, VarType type, int slot) {
    if (type == VALUE_INT) {
        emit_byte(b, OP_ISTORE);
    } else {
        emit_byte(b, OP_BSTORE);
    }
    emit_byte(b, (slot>> 8) & 0xFF);
    emit_byte(b, slot & 0xFF);
}

void emit_load(BytecodeEmitter* b, VarType type, int slot) {
    if (type == VALUE_INT) {
        emit_byte(b, OP_ILOAD);
    } else {
        emit_byte(b, OP_BLOAD);
    }
    emit_byte(b, (slot>> 8) & 0xFF);
    emit_byte(b, slot & 0xFF);
}

void emit_iadd(BytecodeEmitter* b) {
    emit_byte(b, OP_IADD);
}

void emit_isub(BytecodeEmitter* b) {
    emit_byte(b, OP_ISUB);
}

void emit_imul(BytecodeEmitter* b) {
    emit_byte(b, OP_IMUL);
}

void emit_idiv(BytecodeEmitter* b) {
    emit_byte(b, OP_IDIV);
}

void emit_igt(BytecodeEmitter* b) {
    emit_byte(b, OP_IGT);
}

void emit_ilt(BytecodeEmitter* b) {
    emit_byte(b, OP_ILT);
}

void emit_ieq(BytecodeEmitter* b) {
    emit_byte(b, OP_IEQ);
}

void emit_beq(BytecodeEmitter* b) {
    emit_byte(b, OP_BEQ);
}

void emit_neg(BytecodeEmitter* b) {
    emit_byte(b, OP_INEG);
}

void emit_not(BytecodeEmitter* b) {
    emit_byte(b, OP_NOT);
}

int emit_jmpn(BytecodeEmitter* b, int steps) {
    emit_byte(b, OP_JMPN);

    int idx = b->code_size;
    emit_byte(b, (steps>> 8) & 0xFF);
    emit_byte(b, steps & 0xFF);
    return idx;
}

int emit_jmp(BytecodeEmitter* b, int steps) {
    emit_byte(b, OP_JMP);

    int idx = b->code_size;
    emit_byte(b, (steps>> 8) & 0xFF);
    emit_byte(b, steps & 0xFF);
    return idx;
}

void patch_int(BytecodeEmitter* b, int new_val, int starts_at) {
    b->code[starts_at] = (new_val >> 8) & 0xFF;
    b->code[starts_at + 1] = new_val & 0xFF;
}
